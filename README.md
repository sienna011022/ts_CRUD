# 🙌TypeScript & Jest 게시판 CRUD

## ✨기술 스택

> 해당 프로젝트를 수행하며 사용할 기술 스택입니다.

- NodeJs
- Express JS
- TypeScript
- TypeORM

## ✨API 명세서
![api](https://user-images.githubusercontent.com/90383376/209884096-a0f33085-c367-4f31-9502-a5a228c333a0.JPG)

## ✨ERD
![erd](https://user-images.githubusercontent.com/90383376/209883950-b1a13c8f-d849-4355-b509-8262066f9c65.JPG)

## ✨기능

> 구현 기능을 나열하였습니다

- [X] 회원을 등록한다
- [X] 전체 회원을 조회한다

- [X] 전체 게시물을 조회한다
- [X] 전체 사진을 조회한다

- [X] 회원이 게시물을 등록한다
- [X] 게시자와 로그인 된 사용자가 일치하는지 체크한다
- [X] 회원의 게시물을 전체 조회한다
- [X] 회원의 전체 게시물을 삭제한다

- [X] 게시물을 수정한다
- [X] 게시물의 게시자와 로그인한 사용자가 일치해야만 수정할 수 있다.
- [X] 수정시, PK가 아닌 FE에서 생성한 게시물 번호를 이용한다.
- [X] 게시물을 삭제한다
- [X] 게시물의 게시자와 로그인한 사용자가 일치해야만 삭제할 수 있다.
- [X] 게시물에 사진을 등록한다
- [X] 게시물에 사진을 전체 삭제한다
- [ ] 특정 사진을 조회한다
- [ ] 특정 사진을 수정한다
- [ ] 특정 사진을 삭제한다

## ✨짧은 고민들
* N+1 문제 해결
- 1 번의 쿼리를 사용해서 데이터를 가져올 때, 관련된 데이터들을 얻기 위해 추가적으로 N 번의 쿼리가 실행되는 문제 발생하였다.
<br>TypeORM에서는 이러한 N + 1 문제를 find 메서드에 relations 옵션을 적용하거나, QueryBuilder 를 사용해서 조인 쿼리를 통해 해결.

* DTO <-> Etity 빌더 로직을 어디에 넣을까?<br>-  Entity보다 DTO를 사용하면 특정 도메인에 종속되지 않아 범용적으로 사용 가능함.
<br>- DTO안에서 Entity 반환 로직이 들어간다면 DTO에 의해 Entity가 변경 가능한 것으로 보여,Entity의 클린 아키텍처 중 "가장 높은 수준의 규칙을 캡슐화하고 외부 변화에 의해 가장 변하지 않는 부분이어야 한다"의 조건을 위배할 것 같다.
<br>=> 고로 DTO안에서 Entity의 정적 팩토리 메서드를 불러오는 방향으로 구현을 해보았다.

* 검증 로직 <br>
다양한 인증 및 검증 방식이 있겠지만 1주일이라는 시간 안에 해결하기 위하여 우선적으로는 url 파라미터에 있는 정보들로 연관관계 매핑을 이용하여 유효한 엔티티를 찾으려고 노력했다.
Picture를 찾으면, Photo와 연관된 Article을 찾게 되고 이 Article로 User를 찾게 되는 특성을 이용해 ManyToOne 방식으로 Many에 해당하는 Photo를 먼저 찾아 저장된 값과 파라미터를 비교 검증하는 방식을 택하였다. 최대한 쿼리를 날리지 않기 위하여 join을 사용하였다.


## ✨보완하고 싶은 부분들

* DI & IOC 적용 사항 <br>
현재는 각 클래스에서 객체를 만들어서 반환하는 방식이다(객체지향적으로 좋은 설계는 아니라고 생각한다).<br>
DI와 IOC 적용을 위해 typescript에서 자주 사용되는 프레임워크를 비교해 보고 선택한 결과로 가장 쉽고 간편한 typeDI를 알게 되었다. 
하지만 적용을 하려고 했으나, 원인 모를 에러가 발생하였고 시간 상 구현하지 못했음. (시간이 더 주어진다면 꼭 리팩토링 해볼 것)

* 상대 경로 절대 경로<br>
현재는 상대 경로로 표시되어 ../../../가 연속된 경우가 많음. 이 부분 또한 클린한 경로를 위하여 절대 경로로 표시되길 요구된다.

* 예외 처리의 세분화<br>
 다양한 에러가 발생할 여지가 있음에도, 총 4개의 예외만 만들어놓았다. 여러 가지 에러가 발생하는 경우의 수를 인터페이스를 통해 살펴보고 그에 맞는 세세한 예외 처리를 하고 싶다.
 
 * TypeORM 성능 비교
 <br> typeORM안에서도 다양한 선택지가 있었고 어느 계층까지 join을 할까에 대한 고민이 있었다. JOIN이 쿼리를 1개만 날리기는 하지만 , 너무 복잡해지면 성능이 오히려 떨어질것 같았다. 실제 join의 효율성을 검증해보지 못하여서 차후에 비교 해보고싶다.

## ✨ 간단한 회고
자바 프레임워크 스프링만 접해오다가, 이렇게 새로운 프레임 워크만을 사용하여 짧고 굵게 개발을 하게 되어 감회가 새로웠다. 짧은 만큼 아쉬운 구현 사항이 많다. 특히 깊게 디버깅을 하면서 기술을 파악하기 보다는 docs의 예시를 보고 따라 하는 부분이 많아서 조금은 아쉬웠다. 하지만 그럼에도 의식적으로 개발하려고 노력하였던 것 같다. 